Repeater1_GvReport_2_LblMaxno_9 / Repeater1_GvReport_2_TxtNum_9
Repeater1_GvReport_ 0-早餐 1-午餐 2-晚餐
每餐的菜数 len(re.findall(r'Repeater1_GvReport_{0}_LblMaxno_\d'.format(menu_count), page)) - 1（当然，在range的时候就不用- 1了）
menu_count = len(re.findall(r'id="Repeater1_GvReport_(\d)"', page))
def get_course_count(page, menu_sequence):
    return len(re.findall(r'Repeater1_GvReport_{0}_LblMaxno_\d'.format(menu_sequence), page)) - 1

for i in range(0, menu_count):
    course_count.append(get_course_count(page, i))
List Comprehension:
[] for x in range(0, menu_count)

[] for y in range(0, get_course_count(page, x))
course_count = [ [ [] for y in range(0, get_course_count(page, x)) ] for x in range(0, menu_count) ]
for meal_order in course_count:
    
Meal(m_list, order)

class Course(object):
    def __init__(self, seq, course):
        self.id = seq
        self.num = int(course[0])
        self.type = course[1]
        self.name = course[2]
        self.price = float(course[5])
        self.max = int(course[6])
        self.current = int(course[7])


class Meal(dict):
    def __init__(self, seq, menu_list, course_count):
        self.max = course_count
        self.required_course = []
        self.id = seq

        for course_seq in range(course_count):
            start = 9 * course_seq
            end = 9 * (course_seq + 1)
            l = menu_list[start:end]
            # 用于记录必选菜的编号，以处理必选菜不在最后的特殊情况
            if l[4] == '必选':
                self.required_course.append(course_seq)
            self[course_seq] = Course(course_seq, l)

    def __next__(self):
        if self.__current < self.max:
            course = self[self.__current]
            self.__current += 1
            return course
        else:
            raise StopIteration

    def __iter__(self):
        self.__current = 0
        return self


class Menu(dict):
    def __init__(self, page):
        # 只有装着菜单的table是带"id"属性的
        self.meal_count = len(re.findall(r'id="Repeater1_GvReport_(\d)"', page))

        if '<a onclick="return subs();"' in page:
            self.mutable = True
        elif '<a onclick="return msg();"' in page:
            self.mutable = False

        tree = html.fromstring(page)
        course_count = [get_course_count(page, x) for x in range(0, self.meal_count)]
        for meal_seq in range(self.meal_count):
            xpath = '//table[@id="Repeater1_GvReport_{0}"]/tr/td//text()'.format(meal_seq)
            menu_item = tree.xpath(xpath)
            self[meal_seq] = Meal(meal_seq, menu_item, course_count[meal_seq])

    def __next__(self):
        if self.__current < self.meal_count:
            meal = self[self.__current]
            self.__current += 1
            return meal
        else:
            raise StopIteration

    def __iter__(self):
        self.__current = 0
        return self
